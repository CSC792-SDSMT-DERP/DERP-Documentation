\section{Statements and Expressions}
All statements in DERP are a single line of text beginning with some expression 
and ending with the newline character. There is no provision for splitting a 
statement across multiple lines. Most expressions listed in this section are 
valid only in the mode they are listed under, but there is one special expression 
that is always valid: \ecode{stop\_expression}. (A version of the \ecode{recall\_expression} 
is also valid at all times, but the syntax differs depending on the mode, so each version 
will be listed under the appropriate mode heading below)
\begin{center}
    \ecode{statement} \code{: \textit{expression} \bf{'}\n\bf{'}}\\
\end{center}

Rather than list every possible expression type here, we use the convention throughout 
this document that any nonterminal ending with \ecode{\_expression} is a valid production of 
\ecode{expression}.\footnote{It is intentional that on\_exp and with\_exp do not match this convention.}

\subsubsection{Stop}
The Stop expression can be used in any context to switch modes back to the previous mode. In Selection 
or Criteria mode, this means returning to the Main Mode. In Main Mode, the Stop expression is used to 
end the DERP program. If DERP code is being run directly through an interactive interpreter, this should 
end the interpreter loop.

The stop expression is simply one of the keywords stop or exit
\begin{center}
    \ecode{stop\_expression} \code{: stop \bf{\textbar} exit}
\end{center}

\subsection{Main Mode}
The main mode allows users to load and unload modules and to delete, execute, and display the definitions 
of existing criteria and selections.

\subsubsection{Load/Unload}
As mentioned above, source modules are imported code. These imports are done with the \ecode{load\_expression}, 
and sources modules can be unloaded with the \ecode{unload\_expression}. While a source is loaded, its parse 
rules will be used to parse any statements in addition to the standard DERP language rules.

Loading source modules is done with the expression
\begin{center}
    \ecode{unload\_expression} \code{: unload \textit{string}}\\
\end{center}

Where the string given should be the same string name that was used to load the module originally. 
It is not valid to use the unload keyword with a name that was not previously used to load a source module.

\subsubsection{Recall}
The recall expression can be used from Main Mode to retrieve the lines of DERP code that make up a 
criteria or selection. It follows the syntax
\begin{center}
    \ecode{recall\_expression}  \code{:  recall \textit{string}}\\
\end{center}

The string following the keyword recall is the name that was given in a preceding save expression from 
within Criteria Mode or Selection Mode.

\subsubsection{Clear}
The clear expression is used to delete a created Criteria or Selection. After a name is used with the 
\ecode{clear\_expression}, it will not be valid in any future \ecode{read\_expression}, \ecode{recall\_expression}, or \ecode{match\_expression} 
unless a \ecode{create\_expression} is used to assign the string a new selection or criterion
\begin{center}
    \ecode{clear\_expression}  \code{:  clear \textit{string}}\\
\end{center}

\subsubsection{Read}
Read expressions are used to execute a selection and output the resulting Posts. Optionally, a read 
expression can have a sort predicate, which defines the order that the resulting Posts should be outputted.

Read expressions follow the syntax
\begin{center}
    \textit{read\_expression}  :  read \textit{string} \textit{sort\_predicate}\bf{?}\\
    \textit{sort\_predicate}  :  \bf{(}sorted \bf{\textbar} ordered\bf{)} by \textit{sortkey order}\bf{?}\\
    \textit{order}  :  ascending \bf{\textbar} descending\\
\end{center}

The string given immediately after the read keyword should correspond to a previously created selection. 
Any field defined by a source module is to be a valid \textit{sortkey}, however source modules may define additional 
syntax for \textit{sortkey} to allow sorting by more context-specific means. Any posts returned from the selection 
for which the \textit{sortkey} is not relevant (for example, if multiple sources are used in the selection, and the 
\textit{sortkey} is specific to one of the sources) should be sorted to the end of the list in any order.

The DERP language does not define what constitutes ‘outputting posts’ after they are found using a query. 
This leaves the interpreter open to any number of formats for conveying post information to the user. 
It should be noted that DERP selection semantics guarantee that determining which posts can be done on a 
group of posts, and after they are processed they do not need to be re-processed if another group of posts 
is retrieved. This allows interpreters to work with stream sources that can provide a \st{semi-infinite} very 
large result as multiple smaller pieces.

\subsubsection{Create}
The create expression is used exclusively to trigger either selection mode or criteria mode, depending upon 
whether it is used with the criteria or selection keyword.

Create expressions take the form
\begin{center}
    \ecode{create\_expression}  \texttt{:  create \textit{article}\bf{?} new\bf{?} \bf{(}selection \bf{\textbar} criteria\bf{)}}\\
\end{center}

\subsection{Criteria Mode}
After a \ecode{create\_expression} using the keyword \code{criteria} is read, all following statements will be interpreted using 
the criteria creation syntax defined here. Criteria mode ends when the stop statement is found.

Valid expressions in criteria mode can used to add things to the filter or remove them, read back the criteria so 
far, and save the criteria with a name.

\subsubsection{Recall}
The \ecode{recall\_expression} can be used in criteria mode to repeat back the add and remove expressions used for the 
criterion so far.
\begin{center}
    \ecode{recall\_expression}  \code{:  recall}\\
\end{center}
While this is not a particularly useful functionality for users who are writing DERP code in a text file to be 
parsed, it exists in anticipation of DERP interpreters which take input and produce output in some format other 
text on a screen. For example, it would be useful in an implementation of the DERP interpreter which takes voice 
commands.


\subsubsection{Save}
The \ecode{save\_expression} is used to save the set of \ecode{add\_expressions} and \ecode{remove\_expressions} that have been executed since 
criteria mode was last entered. This set of commands is named according to the second part (the \ecode{string}) of the 
expression. Saved criteria become available for use immediately. Using saved criteria is covered with the \code{matching} qualifier
\begin{center}
    \ecode{save\_expression}  \code{:  save as string}\\
\end{center}

\subsubsection{Add/Remove Posts}
The most important expressions in criteria mode are the \ecode{add\_expression} and \ecode{remove\_expression}. They build a sequence of 
executable statements that are used to filter the list of elements. Both expressions have similar form
\begin{center}
    \ecode{add\_expression}  \code{:  add posts selector}\\
    \ecode{remove\_expression}  \code{:  remove posts selector}\\
\end{center}
Both expressions use the selector, which is a series of one or more qualifiers strung together to indicate what 
items from a list of posts should be accepted by the criteria.

    \ecode{selector}  \code{:  \textit{qualifier\_or}\\
    \ecode{qualifier\_or}  \code{:  \textit{qualifier\_or} or \textit{qualifier\_and} \bf{\textbar} \textit{qualifier\_and}\\
    \ecode{qualifier\_and} \code{:  \textit{qualifier\_and} and \textit{qualifier} \bf{\textbar} qualifier}\\

Qualifiers can be combined using the words ‘and’ and ‘or’. Precedence rules for these combine keywords follow standard 
C \textbar\textbar and && precedence. That is, ‘and’ is higher precedence than ‘or’, and both are left-associative. Forcing precedence 
through the use of parentheses, as C allows, is not permitted in DERP.

\ecode{qualifiers} can be any of a number of defined checks. These checks can look at any field exposed as part of the post and 
match it against the requirement given by the code. Some examples of valid qualifiers are \code{“with a date before 1990”}, 
\code{“which are nsfw”}, and \code{“with over twenty upvotes”}\footnote{Provided that source modules are loaded which define the syntax\\
\ecode{Field}  \code{:  \textit{nsfw} \bf{\textbar} \textit{upvotes} \textbar \textit{date}}}
\begin{center}
\ecode{qualifier}  \bf{:}  \ecode{with\_exp article field date\_check date}\\
               \bf{\textbar}  \ecode{with\_exp string substring\_check field}\\
               \bf{\textbar}  \ecode{boolean\_check field}\\
               \bf{\textbar}  \ecode{string\_check field string}\\
               \bf{\textbar}  \ecode{number\_check number field}\\
               \bf{\textbar}  \ecode{on\_exp string}\\
               \bf{\textbar}  \ecode{matching string}\\
\end{center}
With the exception of the matching and \ecode{on\_exp} qualifiers, each of the qualifiers listed here is used to check a single piece of 
information against a \textit{field} associated with a post. Below are the definitions of sub-expressions used in the qualifiers followed 
by the definitions of each of the different \ecode{*\_check} qualifier rules.       
\begin{center}
    \ecode{with\_exp} \code{: with \textit{\textbar} without}
\end{center}

\subusubsection{date\_check}
Date checks, along with the date production, are used in a qualifier to indicate that you would like to filter posts by the date that 
they were published. The date check can be used to get points from an exact date, or a range beginning or ending at a specific date. 
Ranges between two separate dates can be achieved through combining multiple date \ecode{qualifiers} with the keywords and and or.

Dates contain, at minimum, some year; but they may contain a month, and if they contain a month, they may contain a numbered day of 
that month. The keywords on, after, and before correspond to the conventional numerical comparisons =, >, and <.

    
